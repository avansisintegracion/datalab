
 -- 

Intégration
Gestion des bases de données

Sommaire
Les bases de donnée
    Description et utilité 
MySQL
    Description
    Histoire legère
    Utilité général
    Côté relationnel
    La database MySQL
    La table MySQL
        Format possible (description)
        Creation
        Insertion
        Modification
        Suppression
        Affichage
        Recherche (Simple et +RegExp)
    Les limites
MongoDB
    Description
    Histoire légère
    Utilité général
    Côté Document
    La collection mongo
    Le document mongo
        Format possible (description)
        Creation
        Insertion
        Modification
        Suppression
        Recherche
Neo4j
    Description
    Histoire légère
    Utilité général
    Côté graph
    le langage Cypher
    ..



Une entité sur laquelle il est possible de stocker des données de façon organisées et structurées.
Avec la possibilité de consulter et modifier le contenu de ces différentes bases.

Plusieurs types de bases de donnée : 
 - Relationnelles (MySQL)
 - Orienté Document (MongoDB)
 - Orienté graph (Neo4j)

Une base de données où l'information est organisée dans des tableaux à deux dimensions appelés tables.
Les lignes de ces tables sont appelé enregistrmeents et les colonnes sont appelées attributs. 

Exemple de logiciels permettant la manipulation de base de données relationnels : 
(SQL, MS SQL Server, IBM DB2, ORACLE, My-SQL et Microsoft Access)

Tous basé sur SGBDR : Système de gestion de base de données relationnelles



Sauter à la navigationSauter à la recherche
En informatique, une base de données relationnelle est une base de données où l'information est organisée dans des tableaux à deux dimensions appelés des relations ou tables1, selon le modèle introduit par Edgar F. Codd en 1970. Selon ce modèle relationnel, une base de données consiste en une ou plusieurs relations. Les lignes de ces relations sont appelées des nuplets ou enregistrements. Les colonnes sont appelées des attributs.

Les logiciels qui permettent de créer, utiliser et maintenir des bases de données relationnelles sont des systèmes de gestion de base de données relationnels.


un ensemble de données stockées sur un support informatique, organisées et structurées pour pouvoir facilement consulter et modifier leur contenu.

un système pour gérer la base (SGBD) -> opération CRUD (Create, Read, Update, Delete)

un langage pour transmettre des instructions à la base

Les bases de données relationnelles :
paires clé/valeur
colonnes
documents
-> mySQL, SQL server

Les bases de données orientées graphe :
-> Neo4j (+ : langage cypher)
-> Titan ou OrientDB (+ : déploiement multiserveur possible)


MySQL est un serveur de bases de données relationnelles Open Source.

Un serveur de bases de données stocke les données dans des tables séparées plutôt que de tout rassembler dans une seule table. Cela améliore la rapidité et la souplesse de l'ensemble. Les tables sont reliées par des relations définies, qui rendent possible la combinaison de données entre plusieurs tables durant une requête. Le SQL dans "MySQL" signifie "Structured Query Language" : le langage standard pour les traitements de bases de données.

MySQL : SQL signifie Structured Query Language, un langage standard pour les traitements des bases de données.

MySQL est un serveur de bases de données relationnelles Open Source. 
Il à pour but de stocker les données dans des tables séparées et non de tout rassembler dans un seul et même table.
Les tables sont relié par des relations définies, qui rendent possible la combinaison de données entre plusieurs tables durant une requêtes. 


Une base de données de documents est un type de base de données non relationnelle conçu pour stocker des données semi-structurées sous la forme de documents.

Deux langage sont principalement utilisés pour représenter les documents structurés : XML et JSON.

Chaque documents peut avoir la même structure ou une structure différente, et chaque document est auto-descriptif, y compris son éventuel schéma unique. 









Les bases de données de documents sont utilisées de manière intuitive par les développeurs, car les données de la couche applicative sont généralement représentées sous la forme d'un document JSON. Les développeurs peuvent conserver des données en utilisant le même format de modèle de document qu'ils utilisent dans leur code d'application. Dans une base de données, chaque document peut avoir la même structure ou une structure différente, et chaque document est auto-descriptif, y compris son éventuel schéma unique, et ne dépend pas forcément d'un autre document. Les documents sont regroupés dans des « collections », poursuivant un objectif similaire pour une table dans une base de données relationnelle. 

Par exemple,dans une simple base de données composée d'ouvrages, un fichier JSON décrivant un ouvrage peut présenter le code suivant.


Une base de données orientée documents est une base de données destinée aux applications qui gèrent des documents.

Ce type de bases de données peut être une sur-couche d'une base de données relationnelle ou non.

Deux langages sont maintenant principalement utilisés pour représenter les documents structurés : XML et JSON.

L'avantage des bases de données orientées documents est l'unité d'information et l'adaptation à la distribution. En effet, d'une part, comme tout est compris dans la structure cela évite de faire des jointures pour reconstituer l'information car elle n'est plus dispersée dans plusieurs tables. Il n'y a plus besoin de transaction car l'écriture est suffisante pour créer des données sur un document pour modifier un objet. Une seule lecture est suffisante pour reconstituer un document. D'autre part, les documents étant autonomes, on peut les déplacer facilement, ils sont indépendants les uns des autres.

Il existe plusieurs inconvénients : la hiérarchisation d'accès, l'absence de perspective dans la base de données et la perte d'autonomie des entités.

L'objectif d'une base de données orientée documents est la représentation des informations plus ou moins complexes en satisfaisant les besoins suivants :

Flexibilité
Richesse de la structure
Autonomie
Sérialisation

Définition d'une base de données de documents
Une base de données de documents est un type de base de données non relationnelle conçu pour stocker des données semi-structurées sous la forme de documents. Les bases de données de documents sont utilisées de manière intuitive par les développeurs, car les données de la couche applicative sont généralement représentées sous la forme d'un document JSON. Les développeurs peuvent conserver des données en utilisant le même format de modèle de document qu'ils utilisent dans leur code d'application. Dans une base de données, chaque document peut avoir la même structure ou une structure différente, et chaque document est auto-descriptif, y compris son éventuel schéma unique, et ne dépend pas forcément d'un autre document. Les documents sont regroupés dans des « collections », poursuivant un objectif similaire pour une table dans une base de données relationnelle. 

Par exemple,dans une simple base de données composée d'ouvrages, un fichier JSON décrivant un ouvrage peut présenter le code suivant.










Les bases de données orientées graphe sont conçues pour stocker et rechercher des relations. 

Les bases de données orientées graphe recourent à des noeuds pour stocker les entités de données, et à des périphéries pour stocker les relations entre les entités.

Les relations sont des citoyens de première classe dans les bases de données orientées graphe, et la majeure partie de la valeur de ces bases de données est issue de ces relations.


 Les bases de données orientées graphe recourent à des nœuds pour stocker les entités de données, ainsi qu'à des périphéries pour stocker les relations entre les entités. 

 Une périphérie possède toujours un nœud de départ, un nœud de fin, un type et une direction. 

 Un nœud peut décrire les relations, actions, possession parent-enfant, etc. Le nombre et le type de relations qu'un nœud peut avoir sont illimités.
Un graphe contenu dans une base de données orientée graphe peut être traversé le long de types de périphéries spécifiques ou à travers le graphe tout entier. Dans les bases de données orientées graphe, traverser des liaisons ou des relations se fait très rapidement, car les relations entre les nœuds ne sont pas calculés aux temps de demande, mais sont maintenues dans la base de données. Elles possèdent des avantages sur les bases de données relationnelles pour des cas d'utilisation tels que les réseaux sociaux, les moteurs de recommandation ou encore la détection des fraudes, pour lesquelles il est nécessaire d'établir des relations entre des données et d'interroger rapidement ces relations.

Les graphes suivants montrent un exemple de graphe pour un réseau social. Au vu des personnes (nœuds) et de leurs relations (périphéries), vous pouvez déterminer qui sont les « amis des amis » d'une certaine personne : par exemple, les amis des amis d'Howard. 


Et surtout MySQL, qui est un Système de Gestion de Bases de Données Relationnelles (abrégé SGBDR), c'est-à-dire un logiciel qui permet de gérer des bases de données, et donc de gérer de grosses quantités d'informations. Il utilise pour cela le langage SQL. Il s'agit d'un des SGBDR les plus connus et les plus utilisés (YouTube et Wordpress utilisent MySQL, par exemple).


mySQL est un SGBDR crée par Michael Widenius (open source et version commerciale)

mySQL utilise le langage SQL (de façon permissive), souvent combiné à un autre langage de programmation (PHP, Java, Python, C++)

le modèle client-serveur

Les données sont contenues dans des relations = des tables

Différentes opérations peuvent être appliquées aux relations:
une sélection (une partie des lignes) ou une projection (une partie des colonnes
une union A ∪ B, une intersection A ∩ B ou une différence A - B
une jointure

Manipulation de MySQL - database

Afficher les databases existante
Creation d'une database
Suppression d'une database
Supp si exist

Commende manipilation des bases de donnée : 
Creation d'une base de donné 


Une table contient les données sous forme de tableaux.
Toute les colonne d'une table ne sont pas forcement du même type, les types doivent donc être définie en amont avec la creation d'une table.

Type numérique : 
nombres entiers
nombres décimaux

les types alphanumériques :
les chaînes de type texte
les chaînes de type binaire

les types temporels :
Une date




Lorsqu’on définit une colonne dans une table de la base, il faut lui donner un type.

Une table contient les données sous forme de tableaux.
Bien préparer son contenu :
Commencer par savoir quel type de données va être agrégé pour remplir les colonnes
Définir quel type de variable sera utilisé pour les colonne afin d’optimiser la mémoire
Autoriser ou non la possibilité qu’une case soit vide 

Définition d’une table : CREATE TABLE nom_table ( colonne1, …); 
Exemple d’une table contenant les caractéristiques danimaux :

CREATE TABLE Animal (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    espece VARCHAR(40) NOT NULL,
    sexe CHAR(1),
    date_naissance DATETIME NOT NULL,
    nom VARCHAR(30),
    commentaires TEXT,
    PRIMARY KEY (id)
)
ENGINE=INNODB;

CREATE TABLE Terrain (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    taille SMALLINT UNSIGNED NOT NULL,
    type_utilisation VARCHAR(40) NOT NULL,
    prix INT UNSIGNED NOT NULL,
    PRIMARY KEY (id)
)
ENGINE=INNODB;

CREATE TABLE Proprietaire (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    nom VARCHAR(40) NOT NULL,
    prenom VARCHAR(40) NOT NULL,
    PRIMARY KEY (id)
)
ENGINE=INNODB;

CREATE TABLE Terrain_info (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    terrain_id SMALLINT UNSIGNED NOT NULL,
    proprietaire_id SMALLINT UNSIGNED NOT NULL,
    PRIMARY KEY (id)
)
ENGINE=INNODB;


La colonne id permet d'identifier de manière unique chaque ligne.
AUTO_INCREMENT permets d'incrementer les ligne automatiquement
NOT NULL n'autorique pas que la colonne soit vide
SMALLINT, VARCHAR, INT, .. sont les types de donnée
PRIMARY KEY precise quelle colonne correspond au numéro d'identité.
ENGINE correspond au moteur de stockage utilisé.



La colonne id permet d’identifier de manière unique chaque ligne. AUTO_INCREMENT permet de numéroter les lignes automatiquement.
SMALLINT, VARCHAR, ... sont les types de données. Optimise la mémoire dédiée.
La ligne PRIMARY KEY précise quelle colonne correspond au # d’identité.
On termine par le type de moteur de stockage utilisé. La doc peut se trouver ici

modification
Ajouter une colonne : ALTER TABLE nom_table ADD nom_colonne
Supprimer une colonne : ALTER TABLE nom_table DROP nom_colonne
Modifier la description d’une colonne (nom, type de variable, …) : ALTER TABLE nom_table MODIFY nom_colonne type_variable...

insertion
A la main : INSERT INTO Animal (espece, sexe, date_naissance)
         VALUES ('tortue', 'F', '2009-08-03 05:12:00');
A partir d’un fichier .sql : SOURCE monFichier.sql;
A partir d’un fichier .csv :
LOAD DATA LOCAL INFILE fichier.csv'
INTO TABLE Personne
    FIELDS TERMINATED BY ';'
LINES TERMINATED BY '\n'
IGNORE 1 LINES
(nom,prenom,date_naissance);


Lorsqu’on définit une colonne dans une table de la base, il faut lui donner un type.

les types numériques :
nombres entiers (stocker 1308 dans un TYNINT donne 127)
nombres décimaux
valeur exacte :
NUMERIC, DECIMAL
valeur approchée :
FLOAT, DOUBLE, REAL

les types alphanumériques :
les chaînes de type texte : CHAR et VARCHAR, TEXT
les chaînes de type binaire : BINARY et VARBINARY, BLOB

les types temporels :
DATE 'AAAA-MM-JJ'
DATETIME 'AAAA-MM-JJ HH:MM:SS'
TIME 'MM:SS' ou 'J HH:MM:SS'
YEAR
TIMESTAMP (comme DATETIME mais sous une valeur numérique)



Modification d'une table : 


MODIFI
Ajouter une colonne : ALTER TABLE nom_table ADD nom_colonne type_colonne
Supprimer une colonne : ALTER TABLE nom_table DROP nom_colonne
Modification d’une colonne : ALTER TABLE nom_table MODIFY nom_colonne type_colonne

AJOUT
A la main : INSERT INTO Animal (espece, sexe, date_naissance)
         VALUES ('tortue', 'F', '2009-08-03 05:12:00');
A partir d’un fichier .sql : SOURCE monFichier.sql;
A partir d’un fichier .csv :
LOAD DATA LOCAL INFILE fichier.csv'
INTO TABLE Personne
    FIELDS TERMINATED BY ';'
LINES TERMINATED BY '\n'
IGNORE 1 LINES
(nom,prenom,date_naissance);

ALTER TABLE : que l’on ajoute ou modifie une colonne, il faut toujours préciser sa (nouvelle) description complète
Sous forme de listes

En précisant les colonnes

Insertion multiple

En utilisant un .sql :

Ajout de donnée dans la table : 
De façon manuel : 
INSERT INTO nom_table (nom_colonne_cible, ..) VALUES (valeur, ..);

A partir d'un fichier .sql : 
SOURCE nom_fichier.sql


INSERT INTO Terrain (taille, type_utilisation, prix) VALUES (120, 'Indefinie', 15000);
INSERT INTO Terrain (taille, type_utilisation, prix) VALUES (8370, 'Industriel', 2567080);
INSERT INTO Terrain (taille, type_utilisation, prix) VALUES (250, 'Foret', 0);
INSERT INTO Terrain (taille, type_utilisation, prix) VALUES (789, 'Logement', 24879001);
INSERT INTO Terrain (taille, type_utilisation, prix) VALUES (23, 'Base de loisir', 79020);


SELECT (afficher des données)
SELECT … FROM …  (sélectionner des données à partir d’une table) :
SELECT nomColonne FROM nomTable
SELECT * FROM nomTable WHERE conditions

Requêter des données

Attention aux NULL



Il faut bien structurer ses requêtes
soit les animaux nés après 2009 ;
soit les chats :
mâles ;
femelles et nées avant juin 2007.

ORDER BY
(ASC la valeur par défaut)


DISTINCT

Affichage de la table : 
Pour l'afficher en entière :
SELECT * FROM nom_table;

Pour cibler seulement une ou des colonne spécifique de la table : 
SELECT nom_colonne_1 nom_colonne_2 .. FROM nom_table;

Ajout de condition pour filtré les resultat possible

Afficher une sélection filtrée avec WHERE: 
SELECT *
FROM Animal
WHERE date_naissance < '2008-01-01'; -- Animaux nés avant 2008

WHERE peut etre combiné avec différent opérateur 

Afficher des combinaisons de critères à l’aide d’opérateurs logiques:
SELECT 
FROM Animal 
    WHERE espece='chat' 
        AND sexe='F';


Ordonner les requêtes avec ORDER BY :
SELECT *
FROM Animal
WHERE espece='chien'
ORDER BY date_naissance;

==  Test d’égalité de valeurs
=== Test d’égalité de valeurs ou de types de données
<> ou !=  Test de différence entre deux valeurs
!== Test de différence entre deux valeurs ou deux types de données
<   Teste si une valeur est inférieure à une autre
>   Teste si une valeur est supérieure à une autre
<=  Teste si une valeur est inférieure ou égale à une autre
>=  Teste si une valeur est supérieure ou égale à une autre

BETWEEN..AND la valeur testée est située entre deux valeurs données
IN la valeur testée se situe dans une liste valeurs données
NOT IN la valeur testée ne se situe pas dans une liste de valeurs données
LIKE la valeur de gauche correspond à celle de droite (celle de droite peux utiliser le caractère % pour simuler n'importe quel nombre de caractère, et _ pour un seul caractère
NOT LIKE les deux valeurs ne correspondent pas
REGEXP ou RLIKE la valeur de gauche correspond à l'expression régulière donnée
NOT REGEXP la valeur de gauche ne correspond pas à l'expression régulière donnée


Faire des recherches sur l’information commune entre deux tables : jonction de deux tableaux, puis recherche sur la “fusion” des tableaux

Il est possible de faire des recherches dans deux tables différente et de réaliser une jointure (fusion) des tableaux. 

Exemple : on veut avoir une table contenant uniquement le nom du terrain et le nom du propriétaire du terrain.
Il existe différentes possibilités de jointures : 
Jointure internet et Jointure externe
La jointure interne retourne les lignes qui correspondent uniquement. 

Une jointure externe permet de sélectionner aussi les données où il n’y a pas de correspondances.



ans un système de base de données relationnelles les données sont stockées par ligne dans des tables. Et il est souvent nécessaire de faire des jointures sur plusieurs tables afin de tirer des informations assez pertinentes de la base.

---------------


Dans MongoDB, les données sont modélisées sous forme de document sous un style JSON.

On ne parle plus de tables, ni d'enregistrements mais de collections et de documents. Ce système de gestion de données nous évite ainsi de faire des jointures de tables car toutes les informations propres à un certain donnée sont stockées dans un même document.

Les documents sont les unités de base dans une base MongoDB. Ils sont équivalents aux objets JSON et sont comparables aux enregistrements d'une table dans une base de données relationnelle.

Tout document appartient à une collection et a un champ appelé _id qui identifie le document dans la base de données.

MongoDB enregistre les documents sur le disque sous un format BSON (JSON binaire).

Une collection est un ensemble de documents, l'équivalent d'une table en relationnel. Contrairement aux bases de données relationnelles, les champs des documents d'une collection sont libres et peuvent être différents d'un document à un autre. Le seul champ commun est obligatoire est le champ "_id".

Néanmoins pour que la base soit maintenable, il est préférable d'avoir dans une collection des documents de même type

MongoDB est une base de données NoSQL orientée documents. 

Comparé à MySQL, on ne parle plus de tables, ni d'enregistrements mais de collections et de documents.

Les données sont modélisées sous forme de docuement sous un style JSON, les documents sont enregistré sur le disque sous un format BSON (JSON binaire).

Tout document appartient à une collection et a un champ appelé _id qui identifie le document dans la base de données.





Comme nous le verrons, l’ensemble du système tourne autour de cette gestion de documents, y compris le langage d’interrogation, ce qui en fait son point fort. Nous allons nous attaquer dès maintenant à la mise en place d’un serveur Mongo et comment intégrer vos données dans cet environnement.


MongoDB permet de manipuler des données sans schéma prédéterminé (Un champ est obligatoire, la clié primaire "id")





2 types d’éléments :
la paire clé/valeur
le tableau

Sachant qu’une valeur peut être une collection d’autres paires clés/valeurs, et que des paires clé/valeur peuvent être dans un tableau.

L’important est de savoir quelles requêtes seront faites pour décider du format des documents

Pas de jointure pour récupérer des infos mais les informations peuvent être répliquées.

L’important est de savoir quelles requêtes seront faites pour décider du format des documents

Pas de jointure pour récupérer des infos mais les informations peuvent être répliquées.

Base de données : sous forme de collections qui contiennent des documents





Création et utilisation d’une base de données : use nom_base

Insertion de données : db.nom_collection({ objet1:val1, objet2:val2})

db.patients.insert({"nom":"jay gould", "prenom":"stephen", new Date('May 18, 1984')})

db.proprietaire.insert({"nom":"Alpha", "prenom":"Kevin", "age":24, "sexe":"M", "animal":"Chien", "voiture":"Ford"})
db.proprietaire.insert({"nom":"Alpha", "prenom":"Kevin", "age":58, "sexe":"M", "animal":"Chat", "voiture":"Ford"})
db.proprietaire.insert({"nom":"Krije", "prenom":"Paul", "age":45, "sexe":"M", "voiture":"Opel"})
db.proprietaire.insert({"nom":"Olap", "prenom":"Melissa", "age":28, "sexe":"F", "animal":"Ecureuil"})
db.proprietaire.insert({"nom":"Lariss", "prenom":"Laetitia", "age":34, "sexe":"F"})
db.proprietaire.insert({"nom":"Rifl", "prenom":"Marouan", "age":29, "animal":"Chat"})

db.proprietaire.find({"nom":"Alpha", "Sexe":"M"})

db.proprietaire.find({{"age":{$lte:30} ,"age":{$gte:40}}})

db.proprietaire.find({$or: [{"age":{$lte:30}}, {"age":{$gte:40}}]})
db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )


Il est possible de filtré les resultat avec des condition spécifique.
la commande find() peux prendre plusieurs argument. 

exemple : 
db.nom_collection.find({arg1:val1, arg2:val2}) 
Renvoie tout les documents où arg1 vaut val1 ET arg2 vaut val2


Pour une requête précise, on peut utiliser la commande find() en précisant les arguments :
db.nom_collection.find({arg1:val1, champs2:val2}) renvoie tous les éléments dont arg1 vaut champ1 et arg2 vaut champs1.

On peut aussi utiliser des opérateurs de comparaison ou logiques :

Il est possible d'utiliser des opérateurs de comparaison ou logique
$lte : lower than or equal
$lt : lower than
$gte : greater than or equal
$gt : greater than

Et les tests logiques usuels :
$or, $nor, $and, $not

Argument de find() pour récupérer des lignes précises : {champ:1} si oui, {champ:0} si non.
Pour trier l’apparition des résultats : .sort({champ:1}), 1 pour ordre croissant, -1 pour décroissant
Dans le cas de string, c’est l’ordre alphabétique qui est pris en compte :







manipuler des données sans schéma prédéterminé (le seul champ commun et obligatoire est la clé primaire “id”)



Modification de document : 

db.proprietaire.update({"prenom":"Kevin"}, {$set: {"Ville":"Paris"}}, {multi:true})

db.proprietaire.update({"arg":"val"}, {$set: {"newArg":"newVal"}}, {multi:true})
db.proprietaire.remove({"nom":"Alpha"})

Suppression d’un document : 


db.motos.remove({"nom":”Alpha”})

db.nom_collection.remove({arg:val})


db.nom_collection.update({arg:val}, {$push: {arg:val}})


db.proprietaire.update({"nom":"Alpha"}, {$push: {enfants : "kevin"}})

Neo4j est une base de données graphe en Java prévue pour être embarquée dans une application ou accédée en client / serveur via une API REST. La manipulation de graphe en Java avec Neo4j est très naturelle grâce à son API : Node et Relationship sont les principales classes et permettent de modéliser un graphe tout en adjoignant un ensemble de propriétés à chaque nœud et relation.

Neo4j ne supporte actuellement pas la distribution du graphe sur plusieurs instances. Cette fonctionnalité est connue pour être particulièrement complexe à développer de manière efficace. En effet, les nœuds d’un graphe pouvant avoir un nombre arbitraire de relations, il s’agit de trouver un partitionnement qui soit suffisamment efficace pour entraîner un nombre minimum de sauts d’instances lors du parcours d’un graphe. Neo Technology y travaille malgré tout activement, ce qui devrait conduire à une disponibilité d’une version distribuée de Neo4j d’ici la fin de l’année. En attendant, l’éditeur insiste sur le fait que leur base de données se comporte très bien avec plusieurs milliards de nœuds, sur une seule instance.

Le marché des bases de données graphe est restreint. Neo4j y est très visible mais on lui reproche sa licence GPL 3.0 qui requiert l’achat d’une licence commerciale pour une utilisation normale en entreprise. HypergraphDB peut alors être une alternative. D’autres options peuvent être AllegroGraph ou InfoGrid. FlockDB enfin, est une base de données graphe qui est plus simple. Initialement développée par Twitter, elle résout un ensemble de problématiques beaucoup plus restreint afin de permettre un partitionnement sur plusieurs instances et une latence très faible. FlockDB est développé en Scala et s’appuie sur MySQL.

Neo4j est une base de données graphe en Java prévue pour être embarquée dans une application ou accédée en client / serveur via une API REST.
Il permet de représenter les données en tant que nœuds reliés par un ensemble d'arcs, ces objets possédant leurs propres propriétés.
La base de données Neo4j est construite pour être extrêmement performante pour traiter les liens entre noeuds. 

Les traversées utilisent le langage de requête Cypher5, standard de parcours des connexions, élaboré dans le but de réaliser plus simplement que SQL les opérations de parcours ou d'analyse de proximité qui sont les plus courantes lors qu'on traite des données connectées.

Les bases de données de graphes sont des outils puissants pour répondre à des requêtes faisant intervenir des relations entre objets. La recherche du plus court chemin entre deux points du graphe permet par exemple de mettre en place des profils utilisant liens sociaux, géographie et analyse d’impact. 





  Les propriétés sont constitués d'un couple de clé-valeurs de type simple tel que chaînes de caractères ou numérique; celles-ci peuvent êtres indexées. La modélisation est très proche des concepts métier, il n'est pas nécessaire d'utiliser de clés dans Neo4j, car les relations ont une existence propre. L'absence de modélisation rigide rend Neo4j bien adapté à la gestion de données changeantes et de schémas évoluant fréquemment.

La base de données Neo4j est construite pour être extrêmement performante pour traiter les liens entre noeuds. Ces performances sont dues au fait que Neo4j pré-calcule les jointures au moment de l'écriture des données, comparativement aux bases de données relationnelles qui calculent les jointures à la lecture en faisant appel aux Index et à la logique de clés. Ce qui fait de Neo4j une technologie adaptée à de larges ensembles de données connectées.





CREATE (a:Artist { Name : "Strapping Young Lad" })

:clear

s


Noeud represente objets
Noeud peux avoir des proprieter
Relation vers une direction 
Relation peux avoir des proprieter

Creation de noeud

CREATE (identité:label {arg1:val1, arg2:val2, ..}) return identité

CREATE (a:Artist { Name : "Strapping Young Lad" })
CREATE (b:Album { Name : "Heavy as a Really Heavy Thing", Released : "1995" })

CREATE (a_1:Alpha { Name : "Mohamed" }) return a_1
CREATE (a_2:Alpha { Name : "Kevin", age : 29}) return a_2
CREATE (b_1:Beta { Name : "Olymp", age :36, city:"Unknow"}) return b_1
CREATE (b_2:Alpha { Name : "Ralph", city:"Paris"}) return b_2

CREATE (a:Alpha { Name : "Mohamed K" , age : 30}) return a
CREATE (a:Alpha { Name : "Karimou K" , age : 28 }) return a
CREATE (a:Alpha { Name : "Oril P", age : 27 }) return a
CREATE (a:Alpha { Name : "Fabrice Q" , age : 48 }) return a

MATCH (p:Person)
WHERE p.Name = "Devin Townsend"
RETURN p

MATCH (a),(a_1)
WHERE a.Name = "Mohamed K" AND a_1.Name = "Mohamed"
CREATE (a)-[sid:SAME_IDENT]->(a_1)
RETURN a, a_1







CREATE (ee:Person {name:"Emilie",
from:"France"}), (Hans:Person {name:"Hans",
pet:"Kiki"}), (JerM:Movie {title:'Jerry Maguire',
released:2000}, (K:Business{name:”Kernix”,
started_in:2001})

MATCH (tom {name: "Tom Hanks"}) RETURN tom

MATCH (n) RETURN n
MATCH (n) RETURN n
LIMIT 5


Creation de connections : 
MATCH (a:Artist),(b:Album)
WHERE a.Name = "Strapping Young Lad" AND b.Name = "Heavy as a Really Heavy Thing"
CREATE (a)-[r:RELEASED]->(b)
RETURN r




MATCH (a:Alpha)
WHERE a.Name = "Oril P"
RETURN a

MATCH (n {name:"Mohamed"}) return n

MATCH (n)
WHERE {name:"Mohamed"}
RETURN n

MATCH (a:Alpha) 
WHERE a.age >= 30 AND a.age < 50 
RETURN a


MATCH (a:Alpha) WHERE a.age >= 30 AND a.age < 50 RETURN a

MATCH (a:Alpha) WHERE a.age >= 30 AND a.age < 50 RETURN a.Name

 WHERE peux

CREATE CONSTRAINT ON (a:Alpha) ASSERT a.Name IS UNIQUE

Contrainte qui empêche que qu'un label X detenant plusieurs noeud, puisse avoir un ou des propriete identique. 
O

CREATE CONSTRAINT ON (a:Alpha) ASSERT exists(a.Name)

DROP CONSTRAINT ON (identité:label) ASSERT identité.proprieté IS UNIQUE
DROP CONSTRAINT ON (identité:label) ASSERT exists(identité.proprieté)



CREATE CONSTRAINT ON (identité:label) ASSERT exists(identité.proprieté)


CREATE CONSTRAINT ON (identité:label) ASSERT identité.proprieté IS UNIQUE


CREATE (a:Alpha { Name : "Mohamed K" , age : 30}) return a
CREATE (a:Alpha { Name : "Mohamed O", age : 30}) return a


CREATE (ee)-[:LIKES{since:1995}]->(JerM),
(Hans)-[:LIKES]->(ee),
(ee)-[:IGNORES]->(Hans)
CREATE (ee) -[FRIENDS]- (Hans)


MATCH (a:Artist),(b:Album)
WHERE a.Name = "Strapping Young Lad" AND b.Name = "Heavy as a Really Heavy Thing"
CREATE (a)-[r:RELEASED]->(b)
RETURN r

CREATE (a_1)-[dem:DEMO]->(b_1) RETURN dem


CREATE el=(:citoyen)-[:elit_suffrage_univ]->(:president_rep) RETURN c

CREATE (a_1)-[dem:DEMO]->(b_1) RETURN dem

MATCH (a_1:Artist),(b:Album)
WHERE a.Name = "Strapping Young Lad" AND b.Name = "Heavy as a Really Heavy Thing"
CREATE (a)-[r:RELEASED]->(b)
RETURN r

Combiner Match avec Create pour generer les liens souhaiter

MATCH (identité1:label1),(identité2:label2)
WHERE identité1.arg1 = val1 AND identité2.arg2 = val2
CREATE (identité1)-[sid:SAME_IDENT]->(identité2)
RETURN identité1, identité2

CREATE CONSTRAINT ON (identité:label) ASSERT exists(identité.proprieté)


MATCH (a:Alpha),(a_1:Alpha)
WHERE a.Name = "Mohamed K" AND a_1.Name = "Mohamed"
CREATE (a)-[sid:SAME_IDENT]->(a_1)
RETURN a, a_1


Pour cibler des chemins :
MATCH (a)-[:SAME_IDENT]->(a_1) RETURN a, a_1

MATCH (identité1)-[:labal_link]->(identité2) RETURN identité1, identité2


MATCH (n) OPTIONAL MATCH
(n)-[r]-() DELETE n,r

Créer un index pour accélérer les recherches

Crée un index permet d'accélérer les rechercher sur des donnée bien spécifique

CREATE INDEX ON :label(arg)
CREATE INDEX ON :Beta(City)

ENLEBEVR noeud
MATCH (tom{name: “Tom Hanks”}) DETACH
DELETE tom

MATCH (n) DETACH DELETE n

ELEBER label ou proprieter
REMOVE n:Person
REMOVE n.Name

Supprimer un node
MATCH (a:Album {Name: "Killers"}) DELETE a

Plusier node
MATCH (a:Artist {Name: "Iron Maiden"}), (b:Album {Name: "Powerslave"}) 
DELETE a, b

MATCH (n) DELETE n

Pour supprimer un node qui est en relation. 
Il est obligatoire de supprimer la relation avant de supprimer le node en question


Supprimer un noeud
MATCH (identite:label {propriete:val}) DELETE identite

Supprimer plusieurs noeud
MATCH (identite1:label1 {propriete1:val1}), (identite2:label2 {propriete2: val2})
DELETE identite1, identite2

Supprimer tout les noeud
MATCH (n) DELETE n

Pour supprimer un node qui est en relation. 
Il est obligatoire de supprimer la relation avant de supprimer le node en question



MATCH (identité1:label1),(identité2:label2) 
WHERE identité1.propriete1 = val1 AND identité2.propriete2 = val2 
CREATE (identité1)-[sid:SAME_IDENT]->(identité2) 
RETURN identité1, identité2

identite:label
propriete:val


Supprimer relation entre a et b
MATCH (:label1)-[identite_link:label_link]-(:label2) 
DELETE identite_link


Supprime le Noeud + toute ces relation
MATCH (identite:label {propriete: val}) DETACH DELETE identite


Supprime toute la database + relation existante
MATCH (n) DETACH DELETE n







CREATE INDEX ON :député(parti)
MATCH (d:depute {parti:PS})
RETURN COUNT(DISTINCT d)
J’ai crée un index sur la propriété “parti” des noeuds “députés”, accélérant la recherche des députés
appartenant au PS.


Bonjour tout le monde, 

Alors, après un petite discussion avec Héloise et Cyril, j'ai pensé à présenter directement sur Slack "mes compétences". 
Comme en soit, seulement François-Xavier et Joseph ont un visuel sur mes acquis du passé et ça permettra à chacun de me situer un peu.

Je m'excuse d'avance.. ce sera peut-être un peu long. 

Sans trop entrer dans les détails, ces deux dernières années (presque trois), j'ai passé mon temps a manipuler principalement les langages : ASM, C, C++ et Python.
Les projets sur lesquels je travaillais tournais autour de "problème cryptographique" et "problème de satisfiabilité". 
Et des outils graphiques à concevoir (avec Qt, Ubigraph, D3) pour faciliter l'accès / manipulation de données lourde (> 200Go : MySQL, fichier JSON et fichier XML).

J'avais également pour mission de réaliser de la review de code, test de fuzzing et test entropie (Entropie de Shannon) pour certains client de l'entreprise.


J'ai une appétence pour le développement logiciel, l'analyse, la sécurité et la data. 

J'ai des compétences en développement mobile, mais pas aussi développer que mes appétences (Java, Swift, React Native, Dart, Flutter). 
Je ne porte pas le web dans mon coeur (voie du développeur logiciel oblige), mais j'ai eu plusieurs fois ma tête penché sur des projets de développement web (HTML, CSS, PHP, JavaScript, Wordpress et Django)

J'ai été intéressé par le poste de Data Engineer, car j'aurais bien voulu faire une reconversion en tant que Data scientist vu mon goût pour l'analyse et la data, mais cela aurait demandé beaucoup de temps. 
Je suis donc resté sur mes compétences pures pour cibler le Data Engineer :)

Voilà voilà..
Je vais sauter l'étape liste exhaustive des outils / tehcno' que je sais manipuler (ce serait peut-être un peu trop..)











